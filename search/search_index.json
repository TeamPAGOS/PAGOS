{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#overview","title":"Overview","text":"<p>Python Analysis of Groundwater and Ocean Samples (PAGOS) is a Python toolkit for creating and testing hydrological gas exchange models. Datasets from field campaigns containing data for a number of gas tracers can be used to optimise the parameters of gas exchange models, expressed as Python functions. These can be PAGOS' built-in models or user-defined.</p>"},{"location":"#installation","title":"Installation","text":"<p>Use the package manager pip to install PAGOS. PyPi link here.</p> <pre><code>pip install pagos\n</code></pre>"},{"location":"#citation","title":"Citation","text":"<p>To cite PAGOS, please see this Zenodo link. An example (IEEE) citation is given below:</p> <p>S. Scott. PAGOS: Python Analysis of Groundwater and Ocean Samples. (2025) [Online]. Available: https://zenodo.org/records/15675621.</p>"},{"location":"#license","title":"License","text":"<p>BSD-3-Clause, see LICENSE file. PAGOS was developed for Python 3 by Stanley Scott.</p>"},{"location":"Development/contributing/","title":"Contributing","text":"<p>Pull requests are welcome. For major changes, please open an issue first to discuss what you would like to change.</p> <p>Please make sure to update tests as appropriate.</p> <p>Feel free to contact the author Stanley Scott at sscott@iup.uni-heidelberg.de.</p>"},{"location":"Getting%20Started/Usage/","title":"Usage","text":"<p>This is a relatively abridged version of the information you can find in <code>example scripts</code>.</p>"},{"location":"Getting%20Started/Usage/#how-quantities-are-defined-in-pagos","title":"How quantities are defined in PAGOS","text":"<p>This package is designed with a number of \"numerical safeguards\". Quantities used in PAGOS may contain units, and uncertainties. Functions in PAGOS are designed for use with <code>Quantity</code> objects from Pint, but can also be used with regular Python datatypes. The following code produces such a quantity representing the speed 11.2 m/s. <pre><code>from pagos import Q\nmySpeed = Q(11.2, 'm/s')\nprint(mySpeed)\n# -&gt; 11.2000 meter / second\n</code></pre> Those familiar with Pint will recognise <code>Q()</code> as a shortcut for <code>pint.UnitRegistry.Quantity()</code>. This is the PAGOS-safe version though, as it will always refer to the universal <code>UnitRegistry</code> defined in <code>pagos.core</code>.</p>"},{"location":"Getting%20Started/Usage/#water-property-calculations","title":"Water property calculations","text":"<p>The properties of seawater and various gases can be calculated with the <code>water</code> and <code>gas</code> modules. For example, calculating the density of, kinematic viscosity of and vapour pressure over water at a given temperature and salinity: <pre><code>from pagos import water as pwater\nfrom pagos import Q\n\nmyTemp1 = Q(10, 'degC')\nmySal1 = Q(30, 'permille')\n\nmyDensity1 = pwater.calc_dens(myTemp1, mySal1)\nmyDensity2 = pwater.calc_dens(10, 30) # &lt;- default units of degC and permille assumed\n\nprint(myDensity1)\nprint(myDensity2)\n# -&gt; 1023.0511189339445 kilogram / meter ** 3\n# -&gt; 1023.0511189339445 kilogram / meter ** 3\n</code></pre> We can see that the water property function have default, assumed units for any given float arguments (you can see these in the docstrings of the respective functions). PAGOS will also automatically convert units of a different kind:</p> <pre><code>myTemp2 = Q(283.15, 'K')\nmySal2 = Q(3, 'percent')\n\nmyDensity3 = pwater.calc_dens(myTemp2, mySal2)\n\nprint(myDensity3)\n# -&gt; 1023.0511189339445 kilogram / meter ** 3\n</code></pre> <p>Other properties available to be calculated for water are vapour pressure over the water and kinematic viscosity of the water, given temperature and salinity: <pre><code>myVapourPres = pwater.calc_vappres(myTemp1)\nmyKinVisc = pwater.calc_kinvisc(myTemp1, mySal1)\nprint(myVapourPres)\nprint(myKinVisc)\n# -&gt; 12.272370555643239 millibar\n# -&gt; 1.3516218130144556e-06 meter ** 2 / second\n</code></pre></p>"},{"location":"Getting%20Started/Usage/#gas-property-calculations","title":"Gas property calculations","text":"<p>Much like the bulk water properties, properties of gases dissolved in water can also be calculated, namely the equilibrium concentration and the Schmidt number at given temperature, salinity and overlying pressure. Also like the functions in the  <code>water</code> module, the <code>gas</code> module functions have default assumed units which may be overriden by the user. See how all of the following calculations return the same result: <pre><code>from pagos import gas as pgas, Q\nmyTemp, myTempC, myTempK = 20, Q(20, 'degC'), Q(293.15, 'K')\nmySal, mySalpm, mySalpc = 32, Q(32, 'permille'), Q(3.2, 'percent')\nmyPres, myPresatm, myPreshPa = 1, Q(1, 'atm'), Q(1013.25, 'hPa')\n\nCeq1 = pgas.calc_Ceq('Ne', myTemp, mySal, myPres)\nCeq2 = pgas.calc_Ceq('Ne', myTempC, mySalpm, myPresatm)\nCeq3 = pgas.calc_Ceq('Ne', myTempK, mySalpc, myPreshPa)\nSc = pgas.calc_Sc('Ne', myTemp, mySal)\n\nprint('Ceq1(Ne):', Ceq1)\nprint('Ceq2(Ne):', Ceq2)\nprint('Ceq3(Ne):', Ceq3)\nprint('Sc(Ne):', Sc)\n# -&gt; Ceq1(Ne): 1.5676847690725347e-07\n# -&gt; Ceq2(Ne): 1.5676847690725347e-07\n# -&gt; Ceq3(Ne): 1.567684769072535e-07\n# -&gt; Sc(Ne): 300.07687253959057 dimensionless\n</code></pre> Multiple gas properties may be calculated all at once (this is also true of water properties): <pre><code>Ceqs = pgas.calc_Ceq(['Ne', 'Ar', 'N2', 'CFC12'], 20, 32, myPreshPa)\nprint('Ceq(Ne, Ar, N2, CFC12) =', Ceqs, 'ccSTP/g')\n# -&gt; Ceq(Ne, Ar, N2, CFC12) = [1.56768477e-07 2.54842193e-04 9.60586197e-03 2.68527581e-11] ccSTP/g\n</code></pre></p> <p>Note how <code>calc_Ceq</code> returns only a <code>float</code> by default, not a unit-bound <code>Quantity</code>. This is in contrast to most other functions in PAGOS, including <code>calc_Sc</code>, and is set up this way to increase speed when performing inverse modelling(1). The <code>float</code> returned is the value of the equilibrium concentration in units of cc/g, but without the units explicitly returned with it. The unit can be changed, and optionally returned, using the <code>unit</code> and <code>ret_quant</code> arguments:</p> <ol> <li>This is set to be changed in a future version of PAGOS; after great speed improvements, this feature is no longer necessary.</li> </ol> <p><pre><code>Ceqsmolkg = pgas.calc_Ceq('Ne', 20, 32, myPreshPa, 'mol/kg')\nCeqsmolcc = pgas.calc_Ceq('Ne', 20, 32, myPreshPa, 'mol/cc', ret_quant=True)\nprint('Ceq(Ne) =', Ceqsmolkg)\nprint('Ceq(Ne) =', Ceqsmolcc)\n# -&gt; Ceq(Ne) = 6.9908309248701225e-09\n# -&gt; Ceq(Ne) = 7.147959263640384e-12 mole / cubic_centimeter\n</code></pre> Note also here that the different units that one can return are incommensurable with each other (mol/kg has different dimensions to mol/cc). This is another reason why <code>calc_Ceq</code> does not returned a dimensioned object by default - functions in PAGOS which do automatically return dimensioned quantities do so by way of a wrapper, but <code>calc_Ceq</code> cannot be wrapped due to the many incommensurable possibilities of return units.</p>"},{"location":"Getting%20Started/Usage/#creating-and-fitting-models","title":"Creating and fitting models","text":"<p>The real power of PAGOS is in its gas exchange modelling capabilities. PAGOS allows for simple user-definition of gas exchange models. Say we wanted to implement a simple unfractionated excess air (UA) model (that is, equilibrium concentration \\(C^\\mathrm{eq}\\) \"topped up\" with an excess air component):</p> \\[ C_\\mathrm{gas}^\\mathrm{UA}(T, S, p, A) = C_\\mathrm{gas}^\\mathrm{eq}(T, S, p) + A\\cdot z, \\] <p>where \\(A\\) is in the units of \\(C^\\mathrm{eq}_\\mathrm{gas}\\) and \\(z\\) is the atmospheric abundance of the gas. We can implement it very simply like this: <pre><code>from pagos import gas as pgas\nfrom pagos.modelling import GasExchangeModel\ndef ua_model(gas, T, S, p, A):\n    Ceq = pgas.calc_Ceq(gas, T, S, p)\n    z = pgas.abn(gas)   # &lt;- pagos.gas.abn(G) returns the dimensionless atmospheric abundance of G\n    return Ceq + A * z\nUAModel = GasExchangeModel(ua_model, ('degC', 'permille', 'atm', 'cc/g'), 'cc/g')\n</code></pre> The arguments to <code>GasExchangeModel()</code> are the user-defined function describing the model (<code>ua_model</code> above), a tuple of default input units (<code>('degC', 'permille', 'atm', 'cc/g')</code> above) and one default output unit (<code>'cc/g'</code> above). The default input units correspond to the assumed units of the arguments of the model function (<code>(T, S, p, A)</code> above). The output units are those in which the result of the model is expressed. To calculate the result of a model for a given gas, use the <code>run()</code> method of <code>GasExchangeModel</code>. Note that they are default units, but can be overridden: <pre><code># no given units, default units assumed\nmyResult1 = UAModel.run('Ne', 10, 30, 1, 5e-4)\n# units manually given but are the same as the defaults\nmyResult2 = UAModel.run('Ne', Q(10, 'degC'), Q(30, 'permille'), Q(1, 'atm'), Q(5e-4, 'cc/g'))\n# non-default units included, default units of degC and permille overridden\nmyResult3 = UAModel.run('Ne', Q(283.15, 'K'), Q(3, 'percent'), 1, 5e-4)\n\nprint('Result with no given units:', myResult1)\nprint('Result with given units matching defaults:', myResult2)\nprint('Result with overridden units:', myResult3)\n# -&gt; Result with no given units: 1.7903293005762066e-07 cubic_centimeter / gram\n# -&gt; Result with given units matching defaults: 1.7903293005762066e-07 cubic_centimeter / gram\n# -&gt; Result with overridden units: 1.7903293005762066e-07 cubic_centimeter / gram\n</code></pre> If repeatedly typing the <code>Q()</code> constructor isn't to your liking, one can also override default units with the <code>units_in</code> argument thus: <pre><code>myResult4 = UAModel.run('Ne', 283.15, 3, 1, 5e-4, units_in=['K', 'percent', 'atm', 'cc/g'])\nprint('Result using units_in kwarg:', myResult4)\n# -&gt; Result using units_in kwarg: 1.7903293005762066e-07 cubic_centimeter / gram\n</code></pre></p> <p>The returned units may also be altered with the units_out keyword argument. Additionally, note in the example below that the <code>'percent'</code> in <code>units_in</code> is overridden by the explicit <code>Quantity</code> object with its already given <code>'permille'</code> unit. This is a nice safeguard, but also a good reason not to use the <code>units_in</code> argument along with <code>Q()</code>-based model arguments, as <code>units_in</code> will always be silently overridden. <pre><code>myResult5 = UAModel.run('Ne', 10, Q(30, 'permille'), 1, 5e-4, units_in=['degC', 'percent', 'atm', 'cc/g'], units_out='m^3/kg')\nprint('Result in using units_out kwarg:', myResult5)\n# -&gt; Result in using units_out kwarg: 1.790329300576207e-10 meter ** 3 / kilogram\n</code></pre></p>"},{"location":"Getting%20Started/Usage/#inverse-modelling","title":"Inverse Modelling","text":"<p>Parameters of a <code>GasExchangeModel</code>'s function can be fitted using data. A better walkthrough can be found in the <code>example scripts</code> folder, but here is a brief explanation. The <code>GasExchangeModel.fit()</code> method can be used to fit a number of parameters of a gas exchange model using a least-squares minimisation. Here is an example using the Belgium data (from Jung and Aeschbach 2018) taken from the <code>example scripts/example data</code> folder: <pre><code>from pagos.modelling import fitmodel\nimport pandas as pd\n\n# Data import\n# These data are from Jung and Aeschbach 2018 (https://www.sciencedirect.com/science/article/pii/S1364815216307150)\ngases_used = ['Ne', 'Ar', 'Kr', 'Xe']\npangadata = pd.read_csv('example scripts/Example Data/Complete_Input_Data_Samples_Belgium.CSV', sep=',')\nprint('Data from Jung and Aeschbach 2018:')\nprint(pangadata)\n\ndef ua_model(gas, T_recharge, S, p, A):\n    Ceq = pgas.calc_Ceq(gas, T_recharge, S, p)\n    z = pgas.abn(gas)\n    return Ceq + A * z\nUAModel = GasExchangeModel(ua_model, ('degC', 'permille', 'atm', 'cc/g'), None)\n\nfit_UA = UAModel.fit(pangadata,                                             # the data as a Pandas DataFrame\n                     to_fit=['T_recharge', 'A'],                            # the arguments of the model we would like to fit\n                     init_guess=[Q(1, 'degC'), 1e-5],                       # the initial guesses for the parameters to be fit\n                     tracers_used=gases_used,                               # the tracers used for the fitting procedure\n                     constraints=[[-10, 50], [0, 1e-2]],                    # any (optional) constraints we might want to place on our fitted parameters\n                     tqdm_bar=True)                                         # whether to display a progress bar\nprint('Fit of UA model:')\nprint(fit_UA)\n\n# -&gt; Fit of UA model\n#                        T_recharge                                           A\n#    0     7.1+/-0.9 degree_Celsius     0.0023+/-0.0006 cubic_centimeter / gram\n#    1     5.0+/-0.4 degree_Celsius   0.00348+/-0.00029 cubic_centimeter / gram\n#    2     5.0+/-0.4 degree_Celsius   0.00098+/-0.00022 cubic_centimeter / gram\n#    .                 .                                 .\n#    .                 .                                 .\n#    .                 .                                 .\n</code></pre> The arguments are explained in the method docstrings and on the right hand side above. Note here that the init_guess arguments do NOT have to be Quantity objects, although they can be for clarity/safety, if you want. When units are omitted, the <code>default_units_in</code> passed to the <code>GasExchangeModel()</code> constructor are used. So in this case, <code>1e-5</code> becomes <code>1e-5 cc/g</code>.</p>"},{"location":"User%20Guide/Functions/","title":"Functions","text":""},{"location":"User%20Guide/Functions/#gas-and-water-calculations","title":"Gas and Water Calculations","text":"<p>PAGOS supplies a number of functions to calculate properties of water and dissolved gases therein, in the <code>water</code> and <code>gas</code> modules. They are summarised below.</p> Module Function Calculates <code>water.py</code> <code>calc_dens</code> Density \\(\\rho(T, S)\\) of water <code>calc_dens_Sderiv</code> \\(d\\rho/ dS\\) <code>calc_dens_Tderiv</code> \\(d\\rho/ dT\\) <code>calc_kinvisc</code> Kinematic viscosity \\(\\nu(T, S)\\) of water <code>calc_vappres</code> Vapour pressure \\(p_v(T)\\) over water <code>calc_vappres_Tderiv</code> \\(dv_p/ dT\\) <code>gas.py</code> <code>calc_Sc</code> Schmidt number \\(\\mathrm{Sc}(T, S)\\) of a gas in water <code>calc_Ceq</code> Equilibrium concentration \\(C^\\mathrm{eq}(T, S, p)\\) of a gas in water <code>calc_dCeqdp</code> \\(dC^\\mathrm{eq}/dp\\) <code>calc_dCeqdS</code> \\(dC^\\mathrm{eq}/dS\\) <code>calc_dCeqdT</code> \\(dC^\\mathrm{eq}/dT\\) <code>calc_solcoeff</code> Solubility coefficient of a gas <p>PAGOS also provides some getters for gas properties:</p> Module Function Calculates <code>gas.py</code> <code>abn</code> Abundance of gas in the atmosphere <code>ice</code> Ice-water partitioning coefficient of gas <p>These are the functions that provide the backbone for the builtin gas exchange models in PAGOS. They are all unit-aware and \"possibly iterable\", explained in the next sections.</p>"},{"location":"User%20Guide/Functions/#unit-aware","title":"Unit-aware","text":"<p>All of the above functions can handle unit-laden inputs (i.e. <code>Quantity</code> objects), and can work just as well without units being specified, where a default set of units is assumed. For example, the following calculations all produce the same result: <pre><code>from pagos import Q\nfrom pagos.gas import calc_kinvisc\n\nnu1 = calc_kinvisc(10, 8)                               # &lt;- default units of degC and permille assumed\nnu2 = calc_kinvisc(Q(10, 'degC'), Q(8, 'permille'))     # &lt;- units of degC and permille explicitly given\nnu3 = calc_kinvisc(Q(283.15, 'K'), Q(8, 'permille'))    # &lt;- units of Kelvin and permille explicitly given\nnu4 = calc_kinvisc(10, Q(0.8, 'percent'))               # &lt;- mixture of default and specified units\n</code></pre></p> <p>The result of a PAGOS function is usually also a <code>Quantity</code>, and its magnitude can be extracted following these instructions.</p>"},{"location":"User%20Guide/Functions/#possibly-iterable","title":"Possibly Iterable","text":"<p>All of the above functions are wrapped in using a decorator, <code>@_possibly_iterable</code>. This means that the  functions can take in iterables as their arguments as well as single values (one can imagine how this becomes useful when dealing with sets of data rather than one observation). Take the Schmidt number calculation: <pre><code>from pagos import Q\nfrom pagos.gas import calc_Sc\nfrom pagos.constants import NOBLEGASES # ['He', 'Ne', 'Ar', 'Kr', 'Xe']\n\ntemp, sal = Q(5, 'degC'), Q(8, 'permille')\nprint(calc_Sc('He', temp, sal))\n# -&gt; 297.61809773243925 dimensionless\nprint(calc_Sc(NOBLEGASES, temp, sal))\n# -&gt; [297.61809773243925 588.5528683811965 941.6378411255967 1502.8591951053966 1962.5736535043864] dimensionless\n</code></pre></p> <p>Note that the units (here \"<code>dimensionless</code>\") are preserved. We can also control which parameter(s) should be iterated over, with the <code>possit</code> keyword (meaning possibly iterable): <pre><code>temps_array = Q([5, 10, 15, 20, 25], 'degC')\nprint(calc_Sc('He', temps_array, sal, possit=1)) # &lt;- possit=1 declares second argument is the one to be iterated over\nprint(calc_Sc(NOBLEGASES, temps_array, sal, possit=(0, 1))) # both first and second argument are iterated over\nprint(calc_Sc('He', T=temps_array, S=sal, possit='T')) # specification of iteration over keyword argument\n\n# -&gt; [297.61809773243925 234.4123488284571 187.5948551837817 152.21814937390133 125.02497969303147] dimensionless\n# -&gt; [297.61809773243925 452.5787391226707 550.7956064489289 636.8687708031207 618.482428796838] dimensionless\n# -&gt; [297.61809773243925 234.4123488284571 187.5948551837817 152.21814937390133 125.02497969303147] dimensionless\n</code></pre></p> <p>Warning</p> <p>As shown above, this functionality works when specifying iteration over arguments or keyword arguments. However, it does not work with both! A future version of PAGOS may include such a system, where one could conceivably write something like <code>possit=(0, 1, 'S')</code>.</p>"},{"location":"User%20Guide/Modelling/","title":"Modelling","text":"<p>The real power of PAGOS is in its gas exchange modelling capabilities. PAGOS comes packaged with a number of built-in gas exchange models (found in the module <code>builtin_models</code>), but the user may also define whatever model they like (as long as it can be expressed in a Python function!).</p>"},{"location":"User%20Guide/Modelling/#functions-and-the-gasexchangemodel","title":"Functions and the <code>GasExchangeModel</code>","text":"<p>Here, we look at implementing a simple unfractionated excess air (UA) model (that is, equilibrium concentration \\(C^\\mathrm{eq}\\) \"topped up\" with an excess air component). The details of this model can be found in Jung &amp; Aeschbach 2018. The model is written mathematically as</p> \\[ C_\\mathrm{gas}^\\mathrm{UA}(T, S, p, A) = C_\\mathrm{gas}^\\mathrm{eq}(T, S, p) + A\\cdot z, \\] <p>where \\(A\\) is in the units of \\(C^\\mathrm{eq}_\\mathrm{gas}\\) and \\(z\\) is the atmospheric abundance of the gas. Using the functions provided by PAGOS we can express this as the following Python function:</p> <pre><code>from pagos.gas import calc_Ceq, abn\ndef ua_model(gas, T, S, p, A):\n    Ceq = calc_Ceq(gas, T, S, p)\n    z = abn(gas)\n    return Ceq + A * z\n</code></pre> <p>Important</p> <p>The first argument of any function to be used in the modelling framework of PAGOS must be called <code>gas</code> and should take the string-name of the gas for which the model should be run. For example, in the function above, running <code>ua_model('Ne', 10, 30, 1, 2e-5)</code> calculates \\(C^\\mathrm{UA}\\) for neon at 10 \u00b0C, 30 \u2030, 1 atm and 0.00002 cc/g of excess air.</p> <p>So far, so boring. However, PAGOS provides an object, <code>GasExchangeModel</code>, that will handle this function for fitting, automatically taking care things like unit conversion. The constructor looks like this: <pre><code>GasExchangeModel(&lt;function&gt;, &lt;default units in&gt;, &lt;units out&gt;)\n</code></pre> where <code>&lt;function&gt;</code> is the Python function expressing the model of interest, <code>&lt;default units in&gt;</code> are the units that will be assumed are associated with the arguments of <code>&lt;function&gt;</code>, if none are provided by the user, and <code>&lt;units out&gt;</code> are the units of the value returned by the model. Let's take the UA example again: <pre><code>from pagos import GasExchangeModel\nua_gem = GasExchangeModel(ua_model, ('degC', 'permille', 'atm', 'cc/g'), 'cc/g')\n#                            ^         ^         ^         ^      ^        ^\n#                            |         |         |         |      |        |\n#                            |     unit of T     |     unit of p  |   output unit\n#                         function           unit of S        unit of A\n</code></pre> The default units in must match the signature of the original function. Here, it's <code>(T, S, p, A)</code>. Note that the <code>gas</code> argument is not included, and is automatically ignored by PAGOS when setting up the default units (the argument <code>gas</code> takes a string value, which of course has no units).</p> <p>The <code>GasExchangeModel</code> can now be run with user-provided input parameters: <pre><code>from pagos import Q\nprint(ua_gem.run('Ne', 10, 30, 1, 2e-5))\n# -&gt; 1.7030653005762064e-07 cubic_centimeter / gram\nprint(ua_gem.run('Ne', Q(283.15, 'K'), Q(30, 'permille'), Q(1013.25, 'hPa'), Q(2e-5, 'cc/g')))\n# -&gt; 1.7030653005762064e-07 cubic_centimeter / gram\nprint(ua_gem.run('Ne', 283.15, 30, 1013.25, 2e-5,\n                 units_in=['K', 'permille', 'hPa', 'cc/g']))\n# -&gt; 1.7030653005762067e-07 cubic_centimeter / gram\nprint(ua_gem.run('Ne', 283.15, 30, 1013.25, 2e-5,\n                 units_in=['K', 'permille', 'hPa', 'cc/g'],\n                 units_out='m^3/kg'))\n# -&gt; 1.703065300576207e-10 meter ** 3 / kilogram\n</code></pre> Above is demonstrated that <code>GasExchangeModel</code>s are automatically unit-aware, and the units can be handled in a number of ways. On line 2, we see that the default units we provided when we defined <code>ua_gem</code> are used. On line 4, we use quantities already laden with units, using the explicit <code>Q</code> constructor. On line 6, we specify the units of the input parameters in a separate argument, <code>units_in</code>. On line 8, we do the same thing, and also convert the output into units specified by us. The differences in the last digits the results are due to floating point errors.</p>"},{"location":"User%20Guide/Modelling/#fitting-models","title":"Fitting Models","text":"<p>Of course, we do not want only to perform forward-models, but inverse too. This functionality is provided by the <code>fit</code> method of <code>GasExchangeModel</code>. A better walkthrough can be found in the <code>example scripts</code> folder, but here is a brief explanation. The <code>GasExchangeModel.fit()</code> method can be used to fit a number of parameters of a gas exchange model using a least-squares minimisation. Here is an example using the Belgium data (from Jung and Aeschbach 2018) taken from the <code>example scripts/example data</code> folder:</p> <p><pre><code>import pandas as pd\ngases_used = ['Ne', 'Ar', 'Kr', 'Xe']\n\n# Data import\n# These data are from Jung and Aeschbach 2018 (https://www.sciencedirect.com/science/article/pii/S1364815216307150)\npangadata = pd.read_csv('example scripts/Example Data/Complete_Input_Data_Samples_Belgium.CSV', sep=',')\n\nfit_UA = ua_gem.fit(pangadata,                          # the data as a Pandas DataFrame\n                    to_fit=['T', 'A'],                  # the arguments of the model we would like to fit\n                    init_guess=[Q(1, 'degC'), 1e-5],    # the initial guesses for the parameters to be fit\n                    tracers_used=gases_used,            # the tracers used for the fitting procedure\n                    constraints=[[-10, 50], [0, 1e-2]], # any (optional) constraints we might want to place on our fitted parameters\n                    tqdm_bar=True)                      # whether to display a progress bar\nprint('Fit of UA model:')\nprint(fit_UA)\n\n# -&gt; Fit of UA model:\n#                        T_recharge                                           A\n#    0     7.1+/-0.9 degree_Celsius     0.0023+/-0.0006 cubic_centimeter / gram\n#    1     5.0+/-0.4 degree_Celsius   0.00348+/-0.00029 cubic_centimeter / gram\n#    2     5.0+/-0.4 degree_Celsius   0.00098+/-0.00022 cubic_centimeter / gram\n#    ...\n</code></pre> The arguments are explained in the method docstrings and on the right hand side above. Note here that the init_guess arguments do NOT have to be Quantity objects, although they can be for clarity/safety, if you want. When units are omitted, the <code>default_units_in</code> passed to the <code>GasExchangeModel()</code> constructor are used. So in this case, <code>1e-5</code> becomes <code>1e-5 cc/g</code>.</p>"},{"location":"User%20Guide/Quantities%20and%20Magnitudes/","title":"Quantities and Magnitudes","text":""},{"location":"User%20Guide/Quantities%20and%20Magnitudes/#basics","title":"Basics","text":"<p>Quantities used in PAGOS may contain units. Functions in PAGOS are designed for use with <code>Quantity</code> objects from Pint, but can also be used with regular Python datatypes. The following code produces such a quantity representing the speed 11.2 m/s. <pre><code>from pagos import Q\nmySpeed = Q(11.2, 'm/s')\nprint(mySpeed)\n# -&gt; 11.2000 meter / second\n</code></pre> Those familiar with Pint will recognise <code>Q()</code> as a shortcut for <code>pint.UnitRegistry.Quantity()</code>. This is the PAGOS-safe version though, as it will always refer to the universal <code>UnitRegistry</code> defined in <code>pagos.core</code>.</p> <p>Quantities have a <code>magnitude</code> and <code>units</code> property, which extract the magnitude and units respectively: <pre><code>concentration = Q(1e-4, 'mol/kg')\nprint(concentration)\n# -&gt; 0.0001 mole / kilogram\nprint(concentration.magnitude)\n# -&gt; 0.0001\nprint(concentration.units)\n# -&gt; mole / kilogram\n</code></pre></p> <p>Quantities may be expressed in any units one wishes, as long as the unconverted and converted units are commensurable. This is achieved with the <code>Quantity.to</code> method. <pre><code>concentration = Q(1e-4, 'mol/kg')\nprint(concentration)\n# -&gt; 0.0001 mole / kilogram\nprint(concentration.to('umol/kg'))\n# -&gt; 100.0 micromole / kilogram\nprint(concentration.to('mol / mm / s^2 / hPa'))\n# -&gt; 9.999999999999999e-06 mole / hectopascal / millimeter / second ** 2\n</code></pre> We can see here that quantity conversion is not immune to the quirks of floating point arithmetic.</p>"},{"location":"User%20Guide/Quantities%20and%20Magnitudes/#arithmetic","title":"Arithmetic","text":"<p>Quantities with commensurable units can be combined with arithmetic, and the conversions are performed automatically. <pre><code>concentration1 = Q(1e-4, 'mol/kg')\nconcentration2 = Q(2000, 'umol/kg')\n\nconcentration3 = concentration1 + concentration2\n\nprint(concentration3)\n# -&gt; 0.0021 mole / kilogram\n</code></pre></p> <p>Quantities with incommensurable units can still be multiplied/divided (as will be their units), but not added/subtracted. <pre><code>concentration = Q(1e-4, 'mol/kg')\nvelocity = Q(0.5, 'm/s')\n\nflux = concentration * velocity\nprint(flux)\n# -&gt; 5e-05 meter * mole / kilogram / second\n\nbad_quantity = concentration1 + velocity\n# -&gt; pint.errors.DimensionalityError: \n#    Cannot convert from 'mole / kilogram' ([substance] / [mass])\n#    to 'meter / second' ([length] / [time])\n</code></pre></p>"},{"location":"User%20Guide/Quantities%20and%20Magnitudes/#functions-in-pagos-with-quantity-inputsoutputs","title":"Functions in PAGOS with Quantity Inputs/Outputs","text":"<p>Many functions in PAGOS output <code>Quantity</code> objects by default and have the option to have <code>Quantity</code> inputs. For example, let's look at the function to calculate the density of seawater, <code>pagos.water.calc_dens</code>. The inputs to this function are the temperature \\(T\\) and salinity \\(S\\). These can be quantities bearing units of our choice (provided they are indeed units of temperature and salinity - e.g. Kelvin is a valid unit for \\(T\\), but not Joules). Here we see an example with K and \u2030. <pre><code>from pagos.water import calc_dens\nfrom pagos import Q\ntemp = Q(290, 'K')\nsal = Q(20, 'permille')\n\ndensity = calc_dens(temp, sal)\nprint(density)\n# -&gt; 1014.071552984602 kilogram / meter ** 3\n</code></pre> Here we see the output is also a <code>Quantity</code> with units of kilogram per cubic metre.</p>"},{"location":"User%20Guide/Quantities%20and%20Magnitudes/#default-units","title":"Default Units","text":"<p>If the arguments to a PAGOS function are not given as <code>Quantity</code> objects, then their units will be assumed. The default units assumed by a function are shown in the docstring. For example, running <code>help(calc_dens)</code> will output the following <pre><code>Help on function calc_dens in module pagos.water:\n\ncalc_dens(T: float | pint.registry.Quantity, S: float | pint.registry.Quantity) -&gt; pint.registry.Quantity\n    Calculate density of seawater at given temperature and salinity, according to Gill 1982.\\\n    **Default input units** --- `T`:\u00b0C, `S`:\\u2030\\\n    **Output units** --- kg/m\u00b3\n\n...\n</code></pre></p> <p>The default input and output units are shown on lines 5 and 6. We can see a problem here where the permille symbol (\u2030) does not render(1). Also, note that this is actually written for interpretation in markdown; in a markdown-compatible tooltip in an IDE, it would look like this:</p> <ol> <li>This should be changed in a future version of PAGOS to just have \"permille\" written instead of a non-ASCII character.</li> </ol> <p>Calculate density of seawater at given temperature and salinity, according to Gill 1982. Default input units --- <code>T</code>:\u00b0C, <code>S</code>:\u2030 Output units --- kg/m\u00b3</p> <p>Thus, any inputs to the function without explicit units will be assumed to have units of \u00b0C and \u2030: <pre><code>print(calc_dens(15, 20))\n# -&gt; 1014.4433634457197 kilogram / meter ** 3\n</code></pre></p>"},{"location":"User%20Guide/Quantities%20and%20Magnitudes/#returning-magnitudes","title":"Returning Magnitudes","text":"<p>The outputs of PAGOS unit-aware functions can be converted to magnitudes in three different ways:</p> <ol> <li>by explicitly calling the Pint <code>Quantity.magnitude</code> method as discussed above,</li> <li>by including a <code>magnitude=True</code> keyword argument in the function call,</li> <li>by using the <code>snv</code> function from <code>pagos.core</code>.</li> </ol> <pre><code>from pagos.water import calc_dens\nfrom pagos.core import snv\n\nprint(calc_dens(15, 20).magnitude)\nprint(calc_dens(15, 20, magnitude=True))\nprint(snv(calc_dens(15, 20)))\n# -&gt; all print 1014.4433634457197\n</code></pre> <p>Note</p> <p><code>snv</code> is mainly designed for situations where a variable could be a <code>Quantity</code>, a <code>Variable</code> from the uncertainties package or a <code>Quantity</code> whose magnitude is a <code>Variable</code>. For regular <code>Quantities</code> with <code>float</code>-like magnitudes it functions the same as <code>to</code>.</p>"},{"location":"User%20Guide/Quantities%20and%20Magnitudes/#the-unitregistry","title":"The <code>UnitRegistry</code>","text":"<p>It is worth noting that Pint handles units by comparing them to other units inside a <code>UnitRegistry</code> object -  all <code>Quantity</code> objects are constructed from the <code>UnitRegistry</code>, and it contains all the units that Pint is aware of in a given program. One problem that can arise is that Pint units only \"know\" about each other if they come from the same <code>UnitRegistry</code>. I.e. the following code: <pre><code>from pint import UnitRegistry, Quantity\nfrom pagos import Q\nu1 = UnitRegistry()\nmass1 = Q(1, 'kg')\nmass2 = u1.Quantity(2, 'kg')\n\nmass_sum = mass1 + mass2\n</code></pre> will raise a <code>ValueError: Cannot operate with Quantity and Quantity of different registries.</code>. This is something you should be aware of if integrating PAGOS with programs that already use Pint <code>Quantity</code> objects.</p> <p>The <code>UnitRegistry</code> defined by PAGOS can be accessed with <code>pagos.units.u</code>, if absolutely necessary.</p>"}]}